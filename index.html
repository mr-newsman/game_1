<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Egyptian Hieroglyph Starfield - Ultra Optimized</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Egyptian+Hieroglyphs&family=Noto+Sans+Cuneiform&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        #fullscreenBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(212, 175, 55, 0.3);
            color: #d4af37;
            border: 2px solid #d4af37;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 24px;
            z-index: 9999;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
            touch-action: manipulation;
        }

        #fullscreenBtn:hover {
            background: rgba(212, 175, 55, 0.5);
            transform: scale(1.1);
        }

        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            color: rgba(212, 175, 55, 0.5);
            font-family: monospace;
            font-size: 14px;
            z-index: 9999;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="fullscreenBtn" onclick="toggleFullscreen()">â›¶</button>
    <div id="fps"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,
            desynchronized: true, // Better performance on some devices
            willReadFrequently: false
        });
        
        let width, height, dpr;
        
        function resizeCanvas() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Egyptian Hieroglyphs
        const EXCLUDED_GLYPHS = [0x130B8, 0x130B9, 0x130BA];
        const hieroglyphs = [];
        for (let i = 0x13000; i <= 0x1342E; i++) {
            if (!EXCLUDED_GLYPHS.includes(i)) {
                hieroglyphs.push(String.fromCodePoint(i));
            }
        }

        // Sumerian Cuneiform symbols
        const cuneiform = [];
        for (let i = 0x12000; i <= 0x123FF; i++) {
            cuneiform.push(String.fromCodePoint(i));
        }
        for (let i = 0x12400; i <= 0x1247F; i++) {
            cuneiform.push(String.fromCodePoint(i));
        }

        // Safe, school-appropriate emoji ranges with exclusions
        const EMOJI_RANGES = [
            [0x1F600, 0x1F64F], // Emoticons
            [0x1F680, 0x1F6C5], // Transport and Map Symbols
            [0x1F6CB, 0x1F6D2], // Transport and Map Symbols (continued)
            [0x1F6E0, 0x1F6EC], // Transport and Map Symbols (continued)
            [0x1F910, 0x1F96B], // Supplemental Symbols
            [0x1F980, 0x1F9E0], // Supplemental Symbols and Pictographs
            [0x1F400, 0x1F43E], // Animals
            [0x1F440, 0x1F450], // Body parts and hand gestures
            [0x1F300, 0x1F3FA], // Miscellaneous Symbols (weather, nature, sports)
            [0x1F330, 0x1F37D], // Food and Drink
            [0x2600, 0x26FF],   // Miscellaneous Symbols (sun, stars, etc)
            [0x2700, 0x27BF],   // Dingbats
        ];
        
        // Blocked emoji code points (inappropriate for school)
        const BLOCKED_EMOJI = new Set([
            // Pregnant people variants
            0x1F930, 0x1FAC3, 0x1FAC4, 0x1FAC5,
            // Same-sex couple/family emojis (blocking ranges)
            0x1F468, 0x1F469, // When combined with ZWJ sequences
            0x1F46A, 0x1F46B, 0x1F46C, 0x1F46D, // Couples/families
            // Alcohol/drugs
            0x1F37B, 0x1F37A, 0x1F377, 0x1F378, 0x1F379, 0x1F37C,
            0x1F48A, // Pill
            0x1F6AC, // Cigarette
            // Weapons
            0x1F52B, 0x1F5E1, 0x2694, 0x1F3F9, 0x1F4A3, 0x1F9E8,
            // Middle finger and inappropriate gestures
            0x1F595, 0x1F446, 0x1F447, 0x1F448, 0x1F449,
            // Eggplant, peach (often used inappropriately)
            0x1F346, 0x1F351,
            // Religious symbols that might be controversial
            0x262A, 0x262E, 0x262F, 0x2626, 0x2627, 0x1F52F, 0x1F54B, 0x1F54C, 0x1F54D, 0x1F54E,
            // Devil faces
            0x1F608, 0x1F47F,
            // Skulls
            0x1F480, 0x2620, 0x1F571,
            // Kiss/lips
            0x1F48B, 0x1F444, 0x1F48F, 0x1F491,
            // Controversial hand gestures
            0x1F919, 0x1F918, 0x1F91F, 0x1F91E, 0x1F91C,
            // Potentially suggestive
            0x1F445, // Tongue
            0x1F4A6, // Sweat droplets
            0x1F52E, // Crystal ball
            // Money (gambling association)
            0x1F4B0, 0x1F4B4, 0x1F4B5, 0x1F4B6, 0x1F4B7, 0x1F4B8, 0x1F911,
            // Clown (can be used for bullying)
            0x1F921,
            // Potentially scary
            0x1F47B, 0x1F47D, 0x1F47E, 0x1F916, 0x1F479, 0x1F47A,
        ]);
        
        // Generate emoji array from ranges, excluding blocked ones
        function getRandomSafeEmoji() {
            let attempts = 0;
            let codePoint;
            
            while (attempts < 50) { // Max 50 attempts to find safe emoji
                // Pick random range
                const range = EMOJI_RANGES[Math.floor(Math.random() * EMOJI_RANGES.length)];
                codePoint = range[0] + Math.floor(Math.random() * (range[1] - range[0] + 1));
                
                // Re-roll if blocked
                if (!BLOCKED_EMOJI.has(codePoint)) {
                    return String.fromCodePoint(codePoint);
                }
                attempts++;
            }
            
            // Fallback to guaranteed safe emoji if we couldn't find one
            return String.fromCodePoint(0x1F600); // ðŸ˜€ Grinning face
        }

        // PRE-RENDERING CACHE - Massive performance boost!
        class GlyphCache {
            constructor() {
                this.hieroglyphCache = new Map();
                this.cuneiformCache = new Map();
                this.emojiCache = new Map();
            }

            preRenderHieroglyphs() {
                const sizes = [20, 35, 50];
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                sizes.forEach(size => {
                    // Make canvas bigger to accommodate glow without clipping
                    tempCanvas.width = size * 4;
                    tempCanvas.height = size * 4;
                    
                    hieroglyphs.slice(0, 200).forEach(glyph => { // Pre-render subset for memory
                        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Render with glow
                        tempCtx.shadowBlur = 15; // Reduced from 20
                        tempCtx.shadowColor = 'rgba(212, 175, 55, 0.4)'; // Reduced from 0.5
                        tempCtx.font = `${size}px "Noto Sans Egyptian Hieroglyphs", serif`;
                        tempCtx.fillStyle = 'rgba(212, 175, 55, 0.9)';
                        tempCtx.textAlign = 'center';
                        tempCtx.textBaseline = 'middle';
                        tempCtx.fillText(glyph, tempCanvas.width / 2, tempCanvas.height / 2);
                        
                        // Reset shadow immediately
                        tempCtx.shadowBlur = 0;
                        tempCtx.shadowColor = 'transparent';
                        
                        const cached = document.createElement('canvas');
                        cached.width = tempCanvas.width;
                        cached.height = tempCanvas.height;
                        const cachedCtx = cached.getContext('2d');
                        cachedCtx.clearRect(0, 0, cached.width, cached.height);
                        cachedCtx.drawImage(tempCanvas, 0, 0);
                        
                        this.hieroglyphCache.set(`${glyph}-${size}`, cached);
                    });
                });
            }

            preRenderCuneiform() {
                const fontSize = 28;
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = fontSize * 2;
                tempCanvas.height = fontSize * 2;
                
                cuneiform.forEach(symbol => {
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.font = `${fontSize}px "Noto Sans Cuneiform", serif`;
                    tempCtx.fillStyle = 'rgba(212, 175, 55, 0.9)';
                    tempCtx.textAlign = 'center';
                    tempCtx.textBaseline = 'middle';
                    tempCtx.fillText(symbol, tempCanvas.width / 2, tempCanvas.height / 2);
                    
                    const cached = document.createElement('canvas');
                    cached.width = tempCanvas.width;
                    cached.height = tempCanvas.height;
                    cached.getContext('2d').drawImage(tempCanvas, 0, 0);
                    this.cuneiformCache.set(symbol, cached);
                });
            }
        }

        const glyphCache = new GlyphCache();
        
        // Pre-render after fonts load
        document.fonts.ready.then(() => {
            console.log('Fonts loaded, pre-rendering glyphs...');
            glyphCache.preRenderHieroglyphs();
            glyphCache.preRenderCuneiform();
            console.log('Pre-rendering complete!');
        });

        class Hieroglyph {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.char = hieroglyphs[Math.floor(Math.random() * Math.min(200, hieroglyphs.length))];
                const sizes = [20, 35, 50];
                this.size = sizes[Math.floor(Math.random() * sizes.length)];
                this.opacity = 0;
                this.targetOpacity = 0.3 + Math.random() * 0.7;
                this.pulseSpeed = 0.001 + Math.random() * 0.002;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.cycleSpeed = 0.01 + Math.random() * 0.02;
                this.cycleCounter = 0;
                this.fadeIn = true;
                this.fadeSpeed = 0.01 + Math.random() * 0.02;
                this.lifetime = 5000 + Math.random() * 10000;
                this.age = 0;
                this.active = true;
            }
            
            update(dt) {
                if (!this.active) return;
                
                this.age += dt;
                
                if (this.fadeIn && this.opacity < this.targetOpacity) {
                    this.opacity += this.fadeSpeed * dt / 16;
                    if (this.opacity >= this.targetOpacity) {
                        this.fadeIn = false;
                    }
                }
                
                if (this.age > this.lifetime - 1000) {
                    this.opacity -= 0.001 * dt;
                    if (this.opacity <= 0) {
                        this.active = false;
                        return;
                    }
                }
                
                this.pulsePhase += this.pulseSpeed * dt;
                
                this.cycleCounter += this.cycleSpeed * dt;
                if (this.cycleCounter >= 1) {
                    this.cycleCounter = 0;
                    if (Math.random() > 0.5) {
                        this.char = hieroglyphs[Math.floor(Math.random() * Math.min(200, hieroglyphs.length))];
                    }
                }
            }
            
            draw() {
                if (!this.active || this.opacity <= 0) return;
                
                ctx.save(); // Save clean state
                
                const pulse = Math.sin(this.pulsePhase) * 0.15 + 0.85;
                const finalOpacity = this.opacity * pulse;
                
                const cached = glyphCache.hieroglyphCache.get(`${this.char}-${this.size}`);
                if (cached) {
                    ctx.globalAlpha = finalOpacity;
                    ctx.drawImage(cached, 
                        this.x - cached.width / 2, 
                        this.y - cached.height / 2);
                } else {
                    // Fallback if not cached
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `rgba(212, 175, 55, ${finalOpacity * 0.5})`;
                    ctx.font = `${this.size}px "Noto Sans Egyptian Hieroglyphs", serif`;
                    ctx.fillStyle = `rgba(212, 175, 55, ${finalOpacity})`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.char, this.x, this.y);
                }
                
                ctx.restore(); // Restore clean state
            }
        }

        class FallingEmoji {
            constructor() {
                this.reset();
            }
            
            reset(startFalling = true) {
                this.x = Math.random() * (width - 60) + 30;
                this.y = startFalling ? -50 : 0;
                this.char = getRandomSafeEmoji(); // Use new function
                this.size = 30 + Math.random() * 30;
                this.speed = 0.15 + Math.random() * 0.15;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.003;
                this.active = true;
                this.exploding = false;
                this.explosionProgress = 0;
            }
            
            update(dt) {
                if (!this.active) return;
                
                if (this.exploding) {
                    this.explosionProgress += 0.05 * dt / 16;
                    this.rotation += 0.2 * dt / 16;
                    if (this.explosionProgress >= 1) {
                        this.active = false;
                    }
                    return;
                }
                
                this.y += this.speed * dt;
                this.rotation += this.rotationSpeed * dt;
                
                if (this.y > height + 100) {
                    this.active = false;
                }
            }
            
            draw() {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.exploding) {
                    const scale = 1 + this.explosionProgress * 2;
                    const alpha = 1 - this.explosionProgress;
                    ctx.scale(scale, scale);
                    ctx.globalAlpha = alpha;
                    ctx.font = `${this.size * 1.5}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ðŸ’¥', 0, 0);
                } else {
                    ctx.font = `${this.size}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.char, 0, 0);
                }
                
                ctx.restore();
            }
            
            checkHit(x, y) {
                if (this.exploding || !this.active) return false;
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.size;
            }
            
            explode() {
                this.exploding = true;
                this.explosionProgress = 0;
            }
        }

        class CuneiformTicker {
            constructor(side) {
                this.side = side;
                this.symbols = [];
                this.offset = 0;
                this.speed = 0.08;
                this.barHeight = 40;
                this.fontSize = 28;
                this.generateSymbols();
            }
            
            generateSymbols() {
                const numSymbols = this.side === 'left' || this.side === 'right' ? 50 : 100;
                for (let i = 0; i < numSymbols; i++) {
                    this.symbols.push(cuneiform[Math.floor(Math.random() * cuneiform.length)]);
                }
            }
            
            update(dt) {
                this.offset += this.speed * dt;
                
                if (this.offset >= this.fontSize * 1.2) {
                    this.offset = 0;
                    this.symbols.push(cuneiform[Math.floor(Math.random() * cuneiform.length)]);
                    if (this.symbols.length > (this.side === 'left' || this.side === 'right' ? 50 : 100)) {
                        this.symbols.shift();
                    }
                }
            }
            
            draw() {
                ctx.save();
                
                // Clip to prevent overflow glitches
                if (this.side === 'bottom') {
                    ctx.rect(0, height - this.barHeight, width, this.barHeight);
                    ctx.clip();
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';
                    ctx.fillRect(0, height - this.barHeight, width, this.barHeight);
                    this.drawHorizontal(height - this.barHeight / 2, false);
                } else if (this.side === 'top') {
                    ctx.rect(0, 0, width, this.barHeight);
                    ctx.clip();
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';
                    ctx.fillRect(0, 0, width, this.barHeight);
                    this.drawHorizontal(this.barHeight / 2, true);
                } else if (this.side === 'left') {
                    ctx.rect(0, 0, this.barHeight, height);
                    ctx.clip();
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';
                    ctx.fillRect(0, 0, this.barHeight, height);
                    this.drawVertical(this.barHeight / 2, false);
                } else if (this.side === 'right') {
                    ctx.rect(width - this.barHeight, 0, this.barHeight, height);
                    ctx.clip();
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';
                    ctx.fillRect(width - this.barHeight, 0, this.barHeight, height);
                    this.drawVertical(width - this.barHeight / 2, true);
                }
                
                ctx.restore();
            }
            
            drawHorizontal(y, reverse) {
                const charWidth = this.fontSize * 1.2;
                const startX = reverse ? width + this.offset : -this.offset;
                const direction = reverse ? -1 : 1;
                
                for (let i = 0; i < this.symbols.length; i++) {
                    const x = startX + (i * charWidth * direction);
                    if (x >= -charWidth && x <= width + charWidth) {
                        const cached = glyphCache.cuneiformCache.get(this.symbols[i]);
                        if (cached) {
                            ctx.drawImage(cached, x - this.fontSize, y - this.fontSize);
                        }
                    }
                }
            }
            
            drawVertical(x, reverse) {
                ctx.save();
                ctx.translate(x, 0);
                ctx.rotate(Math.PI / 2);
                
                const charWidth = this.fontSize * 1.2;
                const startY = reverse ? height + this.offset : -this.offset;
                const direction = reverse ? -1 : 1;
                
                for (let i = 0; i < this.symbols.length; i++) {
                    const y = startY + (i * charWidth * direction);
                    if (y >= -charWidth && y <= height + charWidth) {
                        const cached = glyphCache.cuneiformCache.get(this.symbols[i]);
                        if (cached) {
                            ctx.drawImage(cached, y - this.fontSize, -this.fontSize);
                        }
                    }
                }
                
                ctx.restore();
            }
        }

        // Object pools
        const hieroglyphPool = [];
        const emojiPool = [];
        const MAX_HIEROGLYPHS = 50;
        const MAX_EMOJIS = 25; // Reduced from 30 for better performance
        
        let emojiRainActive = false;
        let lastEmojiSpawn = 0;
        const EMOJI_SPAWN_INTERVAL = 200;

        for (let i = 0; i < MAX_HIEROGLYPHS; i++) {
            hieroglyphPool.push(new Hieroglyph());
        }

        const tickers = {
            top: new CuneiformTicker('top'),
            bottom: new CuneiformTicker('bottom'),
            left: new CuneiformTicker('left'),
            right: new CuneiformTicker('right')
        };

        // Optimized animation loop
        let lastTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = lastTime;

        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const dt = Math.min(currentTime - lastTime, 50); // Cap delta time
            lastTime = currentTime;
            
            // FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) {
                document.getElementById('fps').textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Clear screen with full black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Reset all canvas state before drawing
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Batch hieroglyph operations
            for (let i = 0; i < hieroglyphPool.length; i++) {
                const glyph = hieroglyphPool[i];
                glyph.update(dt);
                if (!glyph.active) {
                    glyph.reset();
                }
            }
            
            // Draw hieroglyphs
            for (let i = 0; i < hieroglyphPool.length; i++) {
                hieroglyphPool[i].draw();
            }
            
            // Emoji spawning
            if (emojiRainActive && currentTime - lastEmojiSpawn > EMOJI_SPAWN_INTERVAL) {
                const activeCount = emojiPool.filter(e => e.active).length;
                if (activeCount < MAX_EMOJIS) {
                    let emoji = emojiPool.find(e => !e.active);
                    if (!emoji) {
                        emoji = new FallingEmoji();
                        emojiPool.push(emoji);
                    } else {
                        emoji.reset(true);
                    }
                }
                lastEmojiSpawn = currentTime;
            }
            
            // Update and draw emojis
            for (let i = 0; i < emojiPool.length; i++) {
                emojiPool[i].update(dt);
                emojiPool[i].draw();
            }
            
            // Update and draw tickers
            tickers.bottom.update(dt);
            tickers.top.update(dt);
            tickers.left.update(dt);
            tickers.right.update(dt);
            
            tickers.bottom.draw();
            tickers.top.draw();
            tickers.left.draw();
            tickers.right.draw();
        }

        // Input handling
        function handleTap(x, y) {
            if (!emojiRainActive) {
                emojiRainActive = true;
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const emoji = new FallingEmoji();
                        emojiPool.push(emoji);
                    }, i * 100);
                }
                return;
            }
            
            for (let i = emojiPool.length - 1; i >= 0; i--) {
                if (emojiPool[i].checkHit(x, y)) {
                    emojiPool[i].explode();
                    break;
                }
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            handleTap(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleTap(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Fullscreen error: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        animate(performance.now());

        // Auto-refresh on file change detection
        let lastModified = null;
        let checkInterval = 2000; // Check every 2 seconds

        async function checkForUpdates() {
            try {
                const response = await fetch(window.location.href, {
                    method: 'HEAD',
                    cache: 'no-cache'
                });
                
                const currentModified = response.headers.get('Last-Modified');
                
                if (lastModified === null) {
                    lastModified = currentModified;
                } else if (currentModified && currentModified !== lastModified) {
                    console.log('File changed, reloading...');
                    window.location.reload();
                }
            } catch (error) {
                console.log('Update check failed:', error);
            }
        }

        // Start checking for updates
        setInterval(checkForUpdates, checkInterval);
        checkForUpdates(); // Initial check
    </script>
</body>
</html>
