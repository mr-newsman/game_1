<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Egyptian Hieroglyph Starfield - Clean</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Egyptian+Hieroglyphs&family=Noto+Sans+Cuneiform&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        #fullscreenBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(212, 175, 55, 0.3);
            color: #d4af37;
            border: 2px solid #d4af37;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 24px;
            z-index: 9999;
            transition: all 0.3s;
            font-weight: bold;
            touch-action: manipulation;
        }

        #fullscreenBtn:hover {
            background: rgba(212, 175, 55, 0.5);
            transform: scale(1.1);
        }

        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            color: rgba(212, 175, 55, 0.5);
            font-family: monospace;
            font-size: 14px;
            z-index: 9999;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="fullscreenBtn" onclick="toggleFullscreen()">â›¶</button>
    <div id="fps"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let width, height;
        
        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Egyptian Hieroglyphs
        const EXCLUDED_GLYPHS = [0x130B8, 0x130B9, 0x130BA];
        const hieroglyphs = [];
        for (let i = 0x13000; i <= 0x1342E; i++) {
            if (!EXCLUDED_GLYPHS.includes(i)) {
                hieroglyphs.push(String.fromCodePoint(i));
            }
        }

        // Sumerian Cuneiform symbols
        const cuneiform = [];
        for (let i = 0x12000; i <= 0x123FF; i++) {
            cuneiform.push(String.fromCodePoint(i));
        }
        for (let i = 0x12400; i <= 0x1247F; i++) {
            cuneiform.push(String.fromCodePoint(i));
        }

        // Safe emoji ranges with exclusions
        const EMOJI_RANGES = [
            [0x1F600, 0x1F64F], // Emoticons
            [0x1F680, 0x1F6C5], // Transport
            [0x1F6CB, 0x1F6D2],
            [0x1F6E0, 0x1F6EC],
            [0x1F910, 0x1F96B], // Supplemental
            [0x1F980, 0x1F9E0],
            [0x1F400, 0x1F43E], // Animals
            [0x1F440, 0x1F450],
            [0x1F300, 0x1F3FA], // Misc
            [0x1F330, 0x1F37D], // Food
            [0x2600, 0x26FF],
            [0x2700, 0x27BF],
        ];
        
        const BLOCKED_EMOJI = new Set([
            0x1F930, 0x1FAC3, 0x1FAC4, 0x1FAC5,
            0x1F468, 0x1F469, 0x1F46A, 0x1F46B, 0x1F46C, 0x1F46D,
            0x1F37B, 0x1F37A, 0x1F377, 0x1F378, 0x1F379, 0x1F37C,
            0x1F48A, 0x1F6AC,
            0x1F52B, 0x1F5E1, 0x2694, 0x1F3F9, 0x1F4A3, 0x1F9E8,
            0x1F595, 0x1F446, 0x1F447, 0x1F448, 0x1F449,
            0x1F346, 0x1F351,
            0x262A, 0x262E, 0x262F, 0x2626, 0x2627, 0x1F52F, 0x1F54B, 0x1F54C, 0x1F54D, 0x1F54E,
            0x1F608, 0x1F47F,
            0x1F480, 0x2620, 0x1F571,
            0x1F48B, 0x1F444, 0x1F48F, 0x1F491,
            0x1F919, 0x1F918, 0x1F91F, 0x1F91E, 0x1F91C,
            0x1F445, 0x1F4A6, 0x1F52E,
            0x1F4B0, 0x1F4B4, 0x1F4B5, 0x1F4B6, 0x1F4B7, 0x1F4B8, 0x1F911,
            0x1F921,
            0x1F47B, 0x1F47D, 0x1F47E, 0x1F916, 0x1F479, 0x1F47A,
        ]);
        
        function getRandomSafeEmoji() {
            let attempts = 0;
            while (attempts < 50) {
                const range = EMOJI_RANGES[Math.floor(Math.random() * EMOJI_RANGES.length)];
                const codePoint = range[0] + Math.floor(Math.random() * (range[1] - range[0] + 1));
                if (!BLOCKED_EMOJI.has(codePoint)) {
                    return String.fromCodePoint(codePoint);
                }
                attempts++;
            }
            return String.fromCodePoint(0x1F600);
        }

        class Hieroglyph {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.char = hieroglyphs[Math.floor(Math.random() * hieroglyphs.length)];
                const sizes = [20, 35, 50];
                this.size = sizes[Math.floor(Math.random() * sizes.length)];
                this.opacity = 0;
                this.targetOpacity = 0.3 + Math.random() * 0.7;
                this.pulseSpeed = 0.001 + Math.random() * 0.002;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.cycleSpeed = 0.01 + Math.random() * 0.02;
                this.cycleCounter = 0;
                this.fadeIn = true;
                this.fadeSpeed = 0.01 + Math.random() * 0.02;
                this.lifetime = 5000 + Math.random() * 10000;
                this.age = 0;
                this.active = true;
            }
            
            update(dt) {
                if (!this.active) return;
                
                this.age += dt;
                
                if (this.fadeIn && this.opacity < this.targetOpacity) {
                    this.opacity += this.fadeSpeed * dt / 16;
                    if (this.opacity >= this.targetOpacity) {
                        this.fadeIn = false;
                    }
                }
                
                if (this.age > this.lifetime - 1000) {
                    this.opacity -= 0.001 * dt;
                    if (this.opacity <= 0) {
                        this.active = false;
                        return;
                    }
                }
                
                this.pulsePhase += this.pulseSpeed * dt;
                
                this.cycleCounter += this.cycleSpeed * dt;
                if (this.cycleCounter >= 1) {
                    this.cycleCounter = 0;
                    if (Math.random() > 0.5) {
                        this.char = hieroglyphs[Math.floor(Math.random() * hieroglyphs.length)];
                    }
                }
            }
            
            draw() {
                if (!this.active || this.opacity <= 0) return;
                
                const pulse = Math.sin(this.pulsePhase) * 0.15 + 0.85;
                const finalOpacity = this.opacity * pulse;
                
                ctx.save();
                ctx.globalAlpha = finalOpacity;
                ctx.font = `${this.size}px "Noto Sans Egyptian Hieroglyphs", serif`;
                ctx.fillStyle = '#d4af37';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.char, this.x, this.y);
                ctx.restore();
            }
        }

        class FallingEmoji {
            constructor() {
                this.reset();
            }
            
            reset(startFalling = true) {
                this.x = Math.random() * (width - 60) + 30;
                this.y = startFalling ? -50 : 0;
                this.char = getRandomSafeEmoji();
                this.size = 30 + Math.random() * 30;
                this.speed = 0.15 + Math.random() * 0.15;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.003;
                this.active = true;
                this.exploding = false;
                this.explosionProgress = 0;
            }
            
            update(dt) {
                if (!this.active) return;
                
                if (this.exploding) {
                    this.explosionProgress += 0.05 * dt / 16;
                    this.rotation += 0.2 * dt / 16;
                    if (this.explosionProgress >= 1) {
                        this.active = false;
                    }
                    return;
                }
                
                this.y += this.speed * dt;
                this.rotation += this.rotationSpeed * dt;
                
                if (this.y > height + 100) {
                    this.active = false;
                }
            }
            
            draw() {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.exploding) {
                    const scale = 1 + this.explosionProgress * 2;
                    const alpha = 1 - this.explosionProgress;
                    ctx.scale(scale, scale);
                    ctx.globalAlpha = alpha;
                    ctx.font = `${this.size * 1.5}px sans-serif`;
                } else {
                    ctx.font = `${this.size}px sans-serif`;
                }
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.exploding ? 'ðŸ’¥' : this.char, 0, 0);
                ctx.restore();
            }
            
            checkHit(x, y) {
                if (this.exploding || !this.active) return false;
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.size;
            }
            
            explode() {
                this.exploding = true;
                this.explosionProgress = 0;
            }
        }

        class CuneiformTicker {
            constructor(side) {
                this.side = side;
                this.symbols = [];
                this.offset = 0;
                this.speed = 0.08;
                this.barHeight = 40;
                this.fontSize = 28;
                this.generateSymbols();
            }
            
            generateSymbols() {
                const numSymbols = this.side === 'left' || this.side === 'right' ? 50 : 100;
                for (let i = 0; i < numSymbols; i++) {
                    this.symbols.push(cuneiform[Math.floor(Math.random() * cuneiform.length)]);
                }
            }
            
            update(dt) {
                this.offset += this.speed * dt;
                
                if (this.offset >= this.fontSize * 1.2) {
                    this.offset = 0;
                    this.symbols.push(cuneiform[Math.floor(Math.random() * cuneiform.length)]);
                    if (this.symbols.length > (this.side === 'left' || this.side === 'right' ? 50 : 100)) {
                        this.symbols.shift();
                    }
                }
            }
            
            draw() {
                ctx.save();
                
                // Draw background bar
                ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';
                if (this.side === 'bottom') {
                    ctx.fillRect(0, height - this.barHeight, width, this.barHeight);
                    this.drawHorizontal(height - this.barHeight / 2, false);
                } else if (this.side === 'top') {
                    ctx.fillRect(0, 0, width, this.barHeight);
                    this.drawHorizontal(this.barHeight / 2, true);
                } else if (this.side === 'left') {
                    ctx.fillRect(0, 0, this.barHeight, height);
                    this.drawVertical(this.barHeight / 2, false);
                } else if (this.side === 'right') {
                    ctx.fillRect(width - this.barHeight, 0, this.barHeight, height);
                    this.drawVertical(width - this.barHeight / 2, true);
                }
                
                ctx.restore();
            }
            
            drawHorizontal(y, reverse) {
                ctx.font = `${this.fontSize}px "Noto Sans Cuneiform", serif`;
                ctx.fillStyle = 'rgba(212, 175, 55, 0.9)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const charWidth = this.fontSize * 1.2;
                const startX = reverse ? width + this.offset : -this.offset;
                const direction = reverse ? -1 : 1;
                
                for (let i = 0; i < this.symbols.length; i++) {
                    const x = startX + (i * charWidth * direction);
                    if (x >= -charWidth && x <= width + charWidth) {
                        ctx.fillText(this.symbols[i], x, y);
                    }
                }
            }
            
            drawVertical(x, reverse) {
                ctx.save();
                ctx.translate(x, 0);
                ctx.rotate(Math.PI / 2);
                
                ctx.font = `${this.fontSize}px "Noto Sans Cuneiform", serif`;
                ctx.fillStyle = 'rgba(212, 175, 55, 0.9)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const charWidth = this.fontSize * 1.2;
                const startY = reverse ? height + this.offset : -this.offset;
                const direction = reverse ? -1 : 1;
                
                for (let i = 0; i < this.symbols.length; i++) {
                    const y = startY + (i * charWidth * direction);
                    if (y >= -charWidth && y <= height + charWidth) {
                        ctx.fillText(this.symbols[i], y, 0);
                    }
                }
                
                ctx.restore();
            }
        }

        // Object pools
        const hieroglyphPool = [];
        const emojiPool = [];
        const MAX_HIEROGLYPHS = 50;
        const MAX_EMOJIS = 25;
        
        let emojiRainActive = false;
        let lastEmojiSpawn = 0;
        const EMOJI_SPAWN_INTERVAL = 200;

        for (let i = 0; i < MAX_HIEROGLYPHS; i++) {
            hieroglyphPool.push(new Hieroglyph());
        }

        const tickers = {
            top: new CuneiformTicker('top'),
            bottom: new CuneiformTicker('bottom'),
            left: new CuneiformTicker('left'),
            right: new CuneiformTicker('right')
        };

        // Animation loop
        let lastTime = performance.now();
        let frameCount = 0;
        let lastFpsUpdate = lastTime;

        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const dt = Math.min(currentTime - lastTime, 50);
            lastTime = currentTime;
            
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) {
                document.getElementById('fps').textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Clear screen completely
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Update hieroglyphs
            for (let i = 0; i < hieroglyphPool.length; i++) {
                hieroglyphPool[i].update(dt);
                if (!hieroglyphPool[i].active) {
                    hieroglyphPool[i].reset();
                }
            }
            
            // Draw hieroglyphs
            for (let i = 0; i < hieroglyphPool.length; i++) {
                hieroglyphPool[i].draw();
            }
            
            // Emoji spawning
            if (emojiRainActive && currentTime - lastEmojiSpawn > EMOJI_SPAWN_INTERVAL) {
                const activeCount = emojiPool.filter(e => e.active).length;
                if (activeCount < MAX_EMOJIS) {
                    let emoji = emojiPool.find(e => !e.active);
                    if (!emoji) {
                        emoji = new FallingEmoji();
                        emojiPool.push(emoji);
                    } else {
                        emoji.reset(true);
                    }
                }
                lastEmojiSpawn = currentTime;
            }
            
            // Update and draw emojis
            for (let i = 0; i < emojiPool.length; i++) {
                emojiPool[i].update(dt);
                emojiPool[i].draw();
            }
            
            // Update and draw tickers
            tickers.bottom.update(dt);
            tickers.top.update(dt);
            tickers.left.update(dt);
            tickers.right.update(dt);
            
            tickers.bottom.draw();
            tickers.top.draw();
            tickers.left.draw();
            tickers.right.draw();
        }

        // Input handling
        function handleTap(x, y) {
            if (!emojiRainActive) {
                emojiRainActive = true;
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const emoji = new FallingEmoji();
                        emojiPool.push(emoji);
                    }, i * 100);
                }
                return;
            }
            
            for (let i = emojiPool.length - 1; i >= 0; i--) {
                if (emojiPool[i].checkHit(x, y)) {
                    emojiPool[i].explode();
                    break;
                }
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            handleTap(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleTap(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Fullscreen error: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        animate(performance.now());

        // Auto-refresh on file change
        let lastModified = null;
        async function checkForUpdates() {
            try {
                const response = await fetch(window.location.href, {
                    method: 'HEAD',
                    cache: 'no-cache'
                });
                const currentModified = response.headers.get('Last-Modified');
                if (lastModified === null) {
                    lastModified = currentModified;
                } else if (currentModified && currentModified !== lastModified) {
                    console.log('File changed, reloading...');
                    window.location.reload();
                }
            } catch (error) {
                console.log('Update check failed:', error);
            }
        }
        setInterval(checkForUpdates, 2000);
        checkForUpdates();
    </script>
</body>
</html>
